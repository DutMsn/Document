<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Packages :: IvorySQL Document Site</title>
    <link rel="canonical" href="https://docs.ivorysql.org/ivorysql-doc/2.1/compatibility-features-lists/package.html">
    <link rel="prev" href="parameter_settings.html">
    <link rel="next" href="alter_table.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://docs.ivorysql.org">IvorySQL Document Site</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="docs.ivorysql.org">IvorySQL</a>
            <a class="navbar-item" href="docs.ivorysql.org">Migrations</a>
            <a class="navbar-item" href="docs.ivorysql.org">AdminUI</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Migration Services</a>
            <a class="navbar-item" href="#">Remote DBA</a>
            <a class="navbar-item" href="#">Perfornace Tuning</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ivorysql-doc" data-version="2.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../welcome.html">IvorySQL</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../welcome.html">Welcome to IvorySQL</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Compatibility Features</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="parameter_settings.html">Compatibility Parameters</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="package.html">Packages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="alter_table.html">Alter Table</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="delete_table.html">Delete table</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="update_table.html">Update Table</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#compatibility-features-lists/groupby.adoc">compatibility-features-lists/groupby.adoc</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="union.html">Union Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="minus.html">MINUS Operator</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="escape-character.html">Escape Characters</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Global Unique Index</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../global-unique-index-feature/create_global_unique_index.html">Create Global Unique Index</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../global-unique-index-feature/attach_and_detach.html">Attach and Detach</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../global-unique-index-feature/insert_and_update.html">Insert and Update</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">IvorySQL</span>
    <span class="version">2.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../welcome.html">IvorySQL</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../welcome.html">2.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../welcome.html">IvorySQL</a></li>
    <li>Compatibility Features</li>
    <li><a href="package.html">Packages</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/DutMsn/Document/edit/main/modules/ROOT/pages/compatibility-features-lists/package.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Packages</h1>
<div class="sect1">
<h2 id="package-overview"><a class="anchor" href="#package-overview"></a>Package Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section journeys into the “Oracle Style Package” for IvorySQL. A
package, by very definition, is an object or a group of objects packed
together. In terms of databases, this translates into a named schema
object that packages within itself a logically grouped collection of
procedures, functions, variables, cursors, user-defined record types,
and reference records.</p>
</div>
<div class="sect2">
<h3 id="the-need-for-packages"><a class="anchor" href="#the-need-for-packages"></a>The Need for Packages</h3>
<div class="paragraph">
<p>Like similar constructs in various other programming languages, there
are good reasons for using packages with SQL. In this section, we are
going to cover a few.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Reliability and Reusability of Code</p>
<div class="paragraph">
<p>Packages provide the ability to create modular objects that
encapsulate code. This makes the overall design and implementation
simpler. The ability to encapsulate variables, related types, stored
procedures/functions, and cursors, essentially allows creating a
self-contained module that is simple and easy to understand, maintain
and use. Encapsulation comes into play through the exposure of a package
interface, rather than its implementation details, i.e., package body.
This, therefore, benefits in many ways.
Furthermore it allows applications and users to refer to a consistent
interface and not worry about the contents of its body. Also, it
prevents users from making any decisions based on code implementation
as that’s never exposed to them.</p>
</div>
</li>
<li>
<p>Ease of Use</p>
<div class="paragraph">
<p>The ability to create a consistent functional interface in IvorySQL
helps simplify application development by allowing the compilation of
packages without their bodies. Beyond the development phase, the
package allows a user to manage access control on the entire package
rather than individual objects. This is rather valuable especially if
the package contains lots of schema objects.</p>
</div>
</li>
<li>
<p>Performance</p>
<div class="paragraph">
<p>Packages are loaded into memory for maintenance and therefore
utilize minimal I/O resources. Recompilation is simple and only
limited to object(s) changed; dependent objects are not recompiled.</p>
</div>
</li>
<li>
<p>Additional Features</p>
<div class="paragraph">
<p>In addition to performance and ease of use, packages offer
session-wide persistence for variables and cursors. This means
variables and cursors have the same lifetime as a database session
and are destroyed when the session is destroyed.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="package-components"><a class="anchor" href="#package-components"></a>Package Components</h3>
<div class="paragraph">
<p>Package consists of two components. Package specification and Package body.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Package Specification</p>
<div class="paragraph">
<p>Any object within the package that is to be used from the outside is    pecified in the package specification section. This is the publicly    ccessible interface we have been referring to in earlier sections. It oes not contain the definition or implementation of them, i.e. the unctions and the procedures. It only has their headers defined without he body definitions. The variables can be initialized.The following is the list of objects that can be listed in the package specification:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Functions</p>
</li>
<li>
<p>Procedures</p>
</li>
<li>
<p>Cursors</p>
</li>
<li>
<p>Types</p>
</li>
<li>
<p>Variables</p>
</li>
<li>
<p>Constants</p>
</li>
<li>
<p>Record types</p>
</li>
</ul>
</div>
</li>
<li>
<p>Package Body</p>
<div class="paragraph">
<p>The body contains all the implementation code of a package, including
the public interfaces and the private objects. A package body is
optional if the specification does not contain any subprogram or
cursor.</p>
</div>
<div class="paragraph">
<p>It must contain the definition of the subprograms declared in
specification and the corresponding definitions must match.</p>
</div>
<div class="paragraph">
<p>A package body can contain its own subprogram and type declarations
of any internal objects not specified in the specifications. These
objects are then considered private. Private objects cannot be
accessed from outside the package.</p>
</div>
<div class="paragraph">
<p>In addition to subprogram definitions, it can optionally contain a
initializer block that initializes the variables declared in
specification and is executed only once when the first call to
the package is made in a session.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Package body gets invalidated if the specification changes, Care must be
taken when identifying the public interfaces and the private ones to
avoid accidentally exposing critical functions and variables outside the package.</p>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-package"><a class="anchor" href="#creating-package"></a>Creating Package</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="create-package"><a class="anchor" href="#create-package"></a>CREATE PACKAGE</h3>
<div class="paragraph">
<p><code>CREATE PACKAGE</code> Define a new Package specification</p>
</div>
<div class="sect3">
<h4 id="syntax"><a class="anchor" href="#syntax"></a>Syntax</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE [ OR REPLACE ] PACKAGE [schema.] *package_name* [invoker_rights_clause] [IS | AS]
   item_list[, item_list ...]
END [*package_name*];

 `invoker_rights_clause:
    AUTHID [CURRENT_USER | DEFINER]

item_list:
[
   function_declaration    |
   procedure_declaration   |
   type_definition         |
   cursor_declaration      |
   item_declaration
]

function_declaration:
    FUNCTION function_name [(parameter_declaration[, ...])] RETURN datatype;

procedure_declaration:
    PROCEDURE procedure_name [(parameter_declaration[, ...])]

type_definition:
     record_type_definition      |
     ref_cursor_type_definition

cursor_declaration:
   CURSOR name [(cur_param_decl[, ...])] RETURN rowtype;

item_declaration:
     cursor_declaration             |
     cursor_variable_declaration    |
     record_variable_declaration    |
     variable_declaration           |

record_type_definition:

   TYPE record_type IS RECORD  ( variable_declaration [,variable_declaration]... ) ;

ref_cursor_type_definition:
   TYPE type IS REF CURSOR [ RETURN type%ROWTYPE ];

cursor_variable_declaration:
   curvar curtype;

record_variable_declaration:
   recvar { record_type | rowtype_attribute | record_type%TYPE };

variable_declaration:
   varname datatype [ [ NOT NULL ] := expr ]


parameter_declaration:
   parameter_name [IN] datatype [[:= | DEFAULT] expr]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="description"><a class="anchor" href="#description"></a>Description</h4>
<div class="paragraph">
<p>Creates the package specification that contains public declarations.
The declared items in the package specification are accessible from
anywhere in the package and to any other subprograms in the same database.</p>
</div>
<div class="paragraph">
<p>CREATE PACKAGE defines a new package. CREATE OR REPLACE PACKAGE will
either create a new package or replace an existing definition.</p>
</div>
<div class="paragraph">
<p>If a schema name is included, then the package is created in the
specified schema. Otherwise, it is created in the current schema.
The name of the new package must be unique within the schema.</p>
</div>
<div class="paragraph">
<p>When CREATE OR REPLACE PACKAGE is used to replace an existing package,
the ownership and permissions of the package do not change.
All other package properties are assigned the values specified or
implied in the command. Only the owner and member of the owning roles
are allowed to replace the packages.</p>
</div>
<div class="paragraph">
<p>The user that creates the package becomes the owner of the package.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="create-package-body"><a class="anchor" href="#create-package-body"></a>CREATE PACKAGE BODY</h3>
<div class="paragraph">
<p><strong>CREATE PACKAGE BODY</strong> – Define a new Package definition</p>
</div>
<div class="sect3">
<h4 id="syntax-2"><a class="anchor" href="#syntax-2"></a>Syntax</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE [ OR REPLACE ] PACKAGE BODY [schema.] package_name [IS | AS]
   [item_list[, item_list ...]] |
   item_list_2 [, item_list_2 ...]
   [initialize_section]
END [package_name];


initialize_section:
   BEGIN statement[, ...]

item_list:
[
   function_declaration    |
   procedure_declaration   |
   type_definition         |
   cursor_declaration      |
   item_declaration
]

item_list_2:
[
   function_declaration
   function_definition
   procedure_declaration
   procedure_definition
   cursor_definition
]

function_definition:
   FUNCTION function_name [(parameter_declaration[, ...])] RETURN datatype  [IS | AS]
   [declare_section] body;

procedure_definition:
   PROCEDURE procedure_name [(parameter_declaration[, ...])] [IS | AS]
   [declare_section] body;

cursor_definition:
   CURSOR name [(cur_param_decl[, ...])] RETURN rowtype IS select_statement;

body:
   BEGIN statement[, ...] END [name];

statement:
   [&lt;&lt;LABEL&gt;&gt;] pl_statments[, ...];</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="description-2"><a class="anchor" href="#description-2"></a>Description</h4>
<div class="paragraph">
<p><code>CREATE PACKAGE BODY</code> defines the package body for a package.</p>
</div>
<div class="paragraph">
<p><code>CREATE OR REPLACE PACKAGE</code> body will either create a new package body for
the package or replace an existing package body definition.</p>
</div>
<div class="paragraph">
<p>Package specification must be created first to create the package body.</p>
</div>
<div class="paragraph">
<p>The package body contains the implementation of every cursor and subprogram
declared in the package specification created through <code>CREATE PACKAGE</code>.</p>
</div>
<div class="paragraph">
<p>objects defined in a package body are only accessible to outside the package
if their specification is listed in the package specification.</p>
</div>
<div class="paragraph">
<p>For all objects that are only defined in the package body and are not
included in the package specification, they become private members to
the package and are not accessible outside of the package.</p>
</div>
<div class="paragraph">
<p>Both the package and its body must be created in the same schema.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="parameters"><a class="anchor" href="#parameters"></a>Parameters</h3>
<div class="paragraph">
<p><code>package_name</code>
	The name (optionally schema-qualified) of the package to create.'</p>
</div>
<div class="paragraph">
<p><code>invoker_rights_clause</code>
Clause defines whether the package subprograms execute with the privileges of their invoker or definer.</p>
</div>
<div class="paragraph">
<p>The possible options for <code>invoker_rights_clause</code> are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CURRENT_USER</strong>
Indicates that the access privileges for the current user <strong>(invoker)</strong> executing
the package will be used.</p>
</li>
<li>
<p><strong>DEFINER</strong>
This indicates that access privileges for the package creator <strong>(definer)</strong> will be used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>item_list</code>
This is the list of items that can be part of a package.</p>
</div>
<div class="paragraph">
<p><code>procedure_declaration</code>
The procedure signature, i.e. procedure_name(&lt; argument_list &gt;).</p>
</div>
<div class="paragraph">
<p>procedure_declaration can appear in both package specification and package body. Procedure declarations listed in the Package specification makes the procedure public and accessible from outside of the package. While the procedure declared in the package body is considered as a forward declaration and becomes a private member to the package.</p>
</div>
<div class="paragraph">
<p><code>procedure_definition</code>
Implementation/definition of the package procedure.
procedure_definition can only be provided in the package body.
Procedure access specifier is determined by procedure declaration and the
procedures defined in the package body without corresponding declaration
automatically becomes private to the package.</p>
</div>
<div class="paragraph">
<p><code>function_declaration</code>
The function signature and it’s return type, i.e. function_name(&lt; argument_list &gt;) RETURN return_type;.
function_declaration can appear in both package specification and package body.
Function declarations listed in the Package specification makes the function public
and accessible from outside the package. While the function declaration in the package
body is considered as a forward declaration and becomes a private member to the package.</p>
</div>
<div class="paragraph">
<p><code>function_definition</code>
Implementation/definition of the package function.
function_definition can only be provided in the package body.
Function access specifier is determined by function declaration and the function
defined in the package body without corresponding declaration automatically
becomes private to the package.</p>
</div>
<div class="paragraph">
<p><code>type_definition</code>
Either a RECORD, or CURSOR type definition.</p>
</div>
<div class="paragraph">
<p><code>cursor_declaration</code>
CURSOR declaration along with its arguments and return type as the desired ROWTYPE.</p>
</div>
<div class="paragraph">
<p><code>item_declaration</code>
Allows declaration of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cursors</p>
</li>
<li>
<p>Cursor variables</p>
</li>
<li>
<p>Record variables</p>
</li>
<li>
<p>Variables</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>parameter_declaration</code>
Defines the syntax for declaring a parameter. The keyword “IN” if
specified indicates that this is an input parameter. The DEFAULT keyword
followed by an expression (or value) may only be specific for an input
parameter.</p>
</div>
<div class="paragraph">
<p><code>declare_section</code>
This contains all the elements that are local to the function or procedure and can be referenced within its body.</p>
</div>
<div class="paragraph">
<p><code>body</code>
The body consists of the SQL statements or PL control structures that are supported by PL/iSQL language.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-and-accessing-packages"><a class="anchor" href="#creating-and-accessing-packages"></a>Creating and Accessing Packages</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="creating-packages"><a class="anchor" href="#creating-packages"></a>Creating Packages</h3>
<div class="paragraph">
<p>In the previous sections, we have gone through the syntax that dictates the
structure of a package. In this section, we are going to take this a step further by understanding the construction process of a package and how we can access its public elements.</p>
</div>
<div class="paragraph">
<p>As a package is created, IvorySQL will compile it and report any issues it may find. Once the package is successfully compiled, it becomes ready for use.</p>
</div>
</div>
<div class="sect2">
<h3 id="accessing-package-elements"><a class="anchor" href="#accessing-package-elements"></a>Accessing Package Elements</h3>
<div class="paragraph">
<p>A package is instantiated and initialized when it is referenced for the first time in a session.
The following actions are performed in the same order during this process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Assignment of initial values to public constants and variables</p>
</li>
<li>
<p>Execution of the initializer block of the package</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are several ways to access package elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Package functions can be utilized just as any other function in a SELECT statement or from other PL blocks</p>
</li>
<li>
<p>Package procedure can be invoked directly using CALL or from other PL blocks</p>
</li>
<li>
<p>Package variables can be directly read and written using the package name qualification in a PL block.</p>
</li>
<li>
<p>Direct Access Using Dot Notation:
In the dot notation, elements can be accessed in the following
manner:</p>
<div class="ulist">
<ul>
<li>
<p>package_name.func('foo');</p>
</li>
<li>
<p>package_name.proc('foo');</p>
</li>
<li>
<p>package_name.variable;</p>
</li>
<li>
<p>package_name.constant;</p>
</li>
<li>
<p>package_name.other_package.func('foo');</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These statements can be used from inside a PL block or in a SELECT statement if the element   is a function or a procedure.</p>
</div>
</li>
<li>
<p>SQL Call Statement:
Another way is to use the CALL statement. The CALL statement executes
a standalone procedure, or a function defined in a type or package.</p>
<div class="ulist">
<ul>
<li>
<p>CALL package_name.func('foo');</p>
</li>
<li>
<p>CALL package_name.proc('foo');</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="understanding-scope-of-visibility"><a class="anchor" href="#understanding-scope-of-visibility"></a>Understanding Scope of Visibility</h3>
<div class="paragraph">
<p>The scope of variables declared in a PL/iSQL block is limited to that
block. If it has nested blocks, then it will be a global variable to the
nested blocks.
Similarly, if both blocks declare the same name variable, then inside of
the nested block, its own declared variable is visible and the parent
one becomes invisible. To access the parent variable, that variable must be
fully qualified.
Consider the following code snippet.</p>
</div>
<div class="sect3">
<h4 id="example-visibility-and-qualifying-variable-names"><a class="anchor" href="#example-visibility-and-qualifying-variable-names"></a>Example: Visibility and Qualifying Variable Names</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">DECLARE
   x INT;
   y INT;
BEGIN
   -- both blk_1.x and blk_1.y are visible
   &lt;&lt;blk_2&gt;&gt;
   DECLARE
      x INT;
      z INT;
   BEGIN
      -- blk_2.x, y and z are visible
      -- to access blk_1.x it has to be a qualified name. blk_1.x := 0; NULL;
   END;
   -- both x and y are visible
END;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example shows how you must fully qualify a variable name in
case a nested package contains a variable with the same name.</p>
</div>
<div class="paragraph">
<p>Variable name qualification helps in resolving possible confusion that
gets introduced by scope precedence in the following scenarios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Package and nested packages variables: without qualification, nested
takes precedence</p>
</li>
<li>
<p>Package variable and column names: without qualification, column name
takes precedence</p>
</li>
<li>
<p>Function or procedure variable and package variable: without
qualification, package variable takes precedence.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The fields or methods in the following types need to be type qualified.</p>
</div>
</div>
<div class="sect3">
<h4 id="record-type"><a class="anchor" href="#record-type"></a>Record Type</h4>
<div class="paragraph">
<p><strong>Example: Record Type Visibility and Access</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">DECLARE
     x INT;
     TYPE xRec IS RECORD (x char, y INT);
BEGIN
     x := 1; -- will always refer to x(INT) type.
     xRec.x := '2'; -- to refer the CHAR type, it will have to be
qualified name
END;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="examples"><a class="anchor" href="#examples"></a>Examples</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE TABLE test(x INT, y VARCHAR2(100));
INSERT INTO test VALUES (1, 'One');
INSERT INTO test VALUES (2, 'Two');
INSERT INTO test VALUES (3, 'Three');</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="package-specification"><a class="anchor" href="#package-specification"></a>Package Specification</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE OR REPLACE PACKAGE example AUTHID DEFINER AS
   -- Declare public type, cursor, and exception:
   TYPE rectype IS RECORD (a INT, b VARCHAR2(100));
   CURSOR curtype RETURN rectype%rowtype;

   rec rectype;

   -- Declare public subprograms:
   FUNCTION somefunc (
         last_name VARCHAR2,
         first_name VARCHAR2,
         email VARCHAR2
   ) RETURN NUMBER;

   -- Overload preceding public subprogram:
   PROCEDURE xfunc (emp_id NUMBER);
   PROCEDURE xfunc (emp_email VARCHAR2);
END example;
/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="package-body"><a class="anchor" href="#package-body"></a>Package Body</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">CREATE OR REPLACE PACKAGE BODY example AS
   nelems NUMBER; -- private variable, visible only in this package
   -- Define cursor declared in package specification:
   CURSOR curtype RETURN rectype%rowtype IS SELECT x, y
           FROM test
           ORDER BY x;
   -- Define subprograms declared in package specification:
   FUNCTION somefunc (
           last_name VARCHAR2,
           first_name VARCHAR2,
           email VARCHAR2
     ) RETURN NUMBER IS
         id NUMBER := 0;
     BEGIN
         OPEN curtype;
         LOOP
            FETCH curtype INTO rec;
            EXIT WHEN NOT FOUND;
         END LOOP;
         RETURN rec.a;
     END;

   PROCEDURE xfunc (emp_id NUMBER) IS
   BEGIN
      NULL;
   END;

   PROCEDURE xfunc (emp_email VARCHAR2) IS
   BEGIN
      NULL;
   END;

BEGIN -- initialization part of package body
   nelems := 0;
END example;
/
SELECT example.somefunc('Joe', 'M.', 'email@example.com');</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="limitations"><a class="anchor" href="#limitations"></a>Limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Record types are supported as package variables, however they can only
be used within package elements i.e., Package function/procedure can
utilize them.</p>
</div>
<div class="paragraph">
<p>They can not be accessed outside the package, this limitation will be addressed in the next update of IvorySQL.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="parameter_settings.html">Compatibility Parameters</a></span>
  <span class="next"><a href="alter_table.html">Alter Table</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">

</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
